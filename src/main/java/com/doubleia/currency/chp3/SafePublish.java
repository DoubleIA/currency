package com.doubleia.currency.chp3;

/**
 * 
 * @date 2015.8.4 16:44
 * @author wangyingbo
 * @version 3.0.5
 * @description 
 *
 */
public class SafePublish {

	/**
	 * 
	 * public Holder holder;
	 * 
	 * public void initialize() {
	 * 	holder = new Holder();
	 * }
	 * 
	 * 对象未被正确的发布，会导致两个问题：
	 * 1.除了发布对象的线程外，其他线程可以看到的Holder域（Holder未被正确发布）是一个失效值，因此会看到空引用或之前的旧值。
	 * 2.更糟糕的是，线程看到Holder引用值是最新的，而状态值是失效的。某个线程第一次读取的值是失效值，再次读取的值为更新值。
	 * 
	 * 不可变对象与初始化安全性：*
	 * Java内存模型为不可变对象的共享提供了一种特殊的初始化安全性保证。
	 * 如果不使用同步也仍然可以安全的访问对象，则不可变对象必须满足不可变性的三个条件：状态不可修改，所有域都是final的，以及正确的构造过程。
	 * 如果Holder对象是不可变的，则即使Holder没有被正确的发布，也可以确保线程安全性。
	 * 这种保障性可以延伸到对象中所有的final域中，即使没有使用同步，也可以安全的访问final类型的域，
	 * 但是，如果final类型的域指向的是可变对象，那么访问这些域所指向的对象状态时，也要使用同步。
	 * 
	 * 安全发布的常用模式: *
	 * 要安全的发布一个对象，对象的引用及对象的状态要同时对其他线程可见。
	 * 一个正确构造的对象可以按以下几种方式来安全的发布
	 * 1.在静态初始化函数中初始化一个对象的引用。
	 * 2.将对象的引用保存到volatile类型的域或AtomicReference对象中。
	 * 3.将对象的引用保存到某个正确的构造对象的final类型域中。
	 * 4.将对象的引用保存到由锁保存的域中。
	 * 
	 * 放入线程安全的容器中，如Vector或synchronizedList中时，即满足第四条。
	 * 
	 * 线程安全库提供了以下安全发布的保证： *
	 * 1.通过将一个键或值放入HashTable，scychronizedMap或ConcurrentMap中，可以安全的将他发布给任何从这些容器访问他的线程。（直接访问或通过迭代器访问）
	 * 2.通过将某个元素放入Vector，CopyOnWriteArrayList，CopyOnWriteArraySet，scychronizedList或synchronizedSet中，可以安全的将他发布给任何从这些容器访问该元素的线程。
	 * 3.通过将某个元素放入BlockingQueue火车ConcurrentLinkedQueue中，可以将这些元素安全的发布到任何从这些队列访问该元素的线程。
	 * 
	 * Future和Exchanger也可以安全发布对象，涉及时介绍。
	 * 
	 * 通常要发布一个静态初始化对象，最简单和最安全的方式是使用静态初始化器 *
	 * public static Holder holder = new Holder(42);
	 * 原因：
	 * 静态初始化器由JVM在类初始化阶段执行，由于JVM内部存在着同步机制，因此通过这种方式也可以安全的发布。
	 * 
	 * Effectively Immutable Object 事实不可变对象： *
	 * 如果对象从技术上来说是可变的，但是其状态在发布后不会再改变，那么这种对象称为事实不可变对象。 必须满足不可变性的严格定义（见Immutable）。
	 * 在没有额外的同步情况下，任何线程都可以安全的使用事实不可变对象。不仅可以简化开发过程，而且还由于减少了同步而提高了性能。
	 * 例如：
	 * 
	 * public Map<String, Date> lastLogin = Collections.synchronizedMap( new HashMap<String, Date>() );
	 * 
	 * Date在存入Map中将不再变化，那么synchronizedMap中的同步机制就足以使Date被安全的发布，并且在访问这些Date时不需要额外的同步。
	 * 
	 * 对于在构造后可以修改的对象，那么安全发布只能确保“发布当时”的状态可见性，因此，在每次访问对象时需要使用同步来保持后续修改的可见性。要安全的共享可变对象，这些对象必须被安全的发布，线程安全的或者由某个锁保护起来。
	 * 
	 * 总结：对象的发布取决于他的可见性 *
	 * 1.不可变对象可以通过任意机制来发布。
	 * 2.事实不可变对象必须通过安全的方式来发布。
	 * 3.可变对象必须通过安全的方式来发布，并且必须是线程安全的或者由某个锁保护起来。
	 * 
	 * 安全的共享对象： *
	 * 
	 * 获得一个引用时，需要考虑的事情：
	 * 1.使用他之前，是否需要获得一个锁。
	 * 2.是否可以修改他的状态，或是否是只读的。
	 * 
	 * 并发程序中共享对象时，可以使用一些策略：
	 * 1.线程封闭：线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改。
	 * 2.只读共享：在没有额外的同步的情况下，共享的对象可以由多个线程并发访问，但任何线程都不能修改他。包括共享不可变对象和共享事实不可变对象。
	 * 3.线程安全共享：线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步的同步。
	 * 4.保护对象：被保护的对象只能通过持有特定的锁来访问，保护对象封装在其他线程安全中的对象，以及已发布的并且由某个特定锁保护的对象。
	 * 
	 */
	
}
